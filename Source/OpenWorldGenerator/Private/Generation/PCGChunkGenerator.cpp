// Copyright Nikita Zolotukhin. All Rights Reserved.

#include "Generation/PCGChunkGenerator.h"
#include "PCGComponent.h"
#include "PCGManagedResource.h"
#include "PCGSubsystem.h"
#include "Engine/World.h"
#include "Partition/OWGChunk.h"

FName UPCGChunkGenerator::ChunkGeneratorPropertyName = TEXT("OWGInternal_OwnerChunkGenerator");

bool UPCGChunkGenerator::AdvanceChunkGeneration_Implementation()
{
	// Begin the PCG graph execution if we have not done that yet
	if ( !bBegunPCGGeneration && CanStartPCGGeneration())
	{
		bBegunPCGGeneration = BeginPCGGeneration();
		// We are immediately done if we failed to start the generation
		return !bBegunPCGGeneration;
	}
	// We are done when we are no longer waiting for the PCG graph to complete
	return bBegunPCGGeneration && !bWaitingForPCGGraphToComplete;
}

bool UPCGChunkGenerator::CanStartPCGGeneration() const
{
	// Do not attempt to do generate multiple instances of the graph simultaneously since it tanks the CPU pretty hard
	return Graph != nullptr && GetWorld() && GetWorld()->GetSubsystem<UPCGSubsystem>() &&
		!GetWorld()->GetSubsystem<UPCGSubsystem>()->IsGraphCurrentlyExecuting( Graph->GetGraph() );
}

void UPCGChunkGenerator::EndChunkGeneration_Implementation()
{
	// Cleanup the state of the PCG component
	EndPCGGeneration();
}

bool UPCGChunkGenerator::CanPersistChunkGenerator_Implementation() const
{
	// We cannot persist the PCG state and as such we cannot be persisted if the PCG generation is still running
	return bBegunPCGGeneration || bWaitingForPCGGraphToComplete;
}

void UPCGChunkGenerator::NotifyAboutToUnloadChunk_Implementation()
{
	// If we are still generating at this point and we are about to unload the chunk, we need to scratch all of our currently done work and start over when the chunk is loaded again
	if ( !CanPersistChunkGenerator() )
	{
		AbortPCGGeneration();
	}
}

bool UPCGChunkGenerator::BeginPCGGeneration()
{
	// Avoid trying to generate an invalid graph
	if ( !IsValid( Graph ) )
	{
		UE_LOG( LogChunkGenerator, Warning, TEXT("Chunk Generator '%s' failed to run because no PCG graph was specified"), *GetFullName() );
		return false;
	}

	// Create graph instance so that we can bind the graph to the generator
	GraphInstance = CastChecked<UPCGGraphInstance>( UPCGGraphInstance::CreateInstance( this, Graph ) );
	ConfigurePCGGraph( GraphInstance );

	// We only want to set the graph locally. We will replicate the spawned components, as opposed to replicating the graph itself.
	UPCGComponent* PCGComponent = GetChunk()->PCGComponent;
	PCGComponent->SetGraphLocal( GraphInstance );

	// Bind to the delegate that specifies whenever the generation was complete and wait until it's triggered
	PCGComponent->OnPCGGraphGeneratedDelegate.AddUObject( this, &UPCGChunkGenerator::OnPCGGraphGenerationComplete );
	bWaitingForPCGGraphToComplete = true;

	PCGComponent->GenerateLocal( true );
	return true;
}

void UPCGChunkGenerator::ConfigurePCGGraph_Implementation( UPCGGraphInstance* PCGGraphInstance )
{
	PCGGraphInstance->ParametersOverrides.Parameters.AddProperty( ChunkGeneratorPropertyName, EPropertyBagPropertyType::Object, UPCGChunkGenerator::StaticClass() );
	PCGGraphInstance->ParametersOverrides.Parameters.SetValueObject( ChunkGeneratorPropertyName, this );
}

void UPCGChunkGenerator::AbortPCGGeneration()
{
	// Reset our state
	bBegunPCGGeneration = false;
	bWaitingForPCGGraphToComplete = false;

	// Migrate the resources generated by the PCG to the chunk actor, or claim their ownership so that the cleanup of the PCG component would not destroy them
	UPCGComponent* PCGComponent = GetChunk()->PCGComponent;
	PCGComponent->OnPCGGraphGeneratedDelegate.RemoveAll( this );

	// Cancel the generation and immediately cleanup the state of the PCG component without migrating the resources to the chunk
	PCGComponent->CancelGeneration();
	PCGComponent->CleanupLocalImmediate( true );
}

void UPCGChunkGenerator::EndPCGGeneration()
{
	// Reset our state
	bBegunPCGGeneration = false;
	bWaitingForPCGGraphToComplete = false;

	// Migrate the resources generated by the PCG to the chunk actor, or claim their ownership so that the cleanup of the PCG component would not destroy them
	UPCGComponent* PCGComponent = GetChunk()->PCGComponent;
	PCGComponent->OnPCGGraphGeneratedDelegate.RemoveAll( this );
	PCGComponent->ForEachManagedResource( [&]( UPCGManagedResource* ManagedResource )
	{
		MigratePCGManagedResourceToChunk( ManagedResource );
	} );

	// Immediately cleanup the state of the PCG component and remove our graph from it
	PCGComponent->CleanupLocalImmediate( true );
}

void UPCGChunkGenerator::MigratePCGManagedResourceToChunk( UPCGManagedResource* ManagedResource )
{
	// We do not need to do anything to migrate the Actor Component resources, they are already parented to the chunk
	// We just need to make the managed resource forgot their generated component and potentially rename it to avoid conflicts
	if ( UPCGManagedComponent* PCGManagedComponent = Cast<UPCGManagedComponent>( ManagedResource ) )
	{
		// Rename the component to signify the linkage between the current chunk generator and the component and avoid conflicts with other chunk generators
		if ( PCGManagedComponent->GeneratedComponent )
		{
			const FString NewComponentName = FString::Printf( TEXT("%s_%s"), *GetClass()->GetName(), *PCGManagedComponent->GetName() );
			PCGManagedComponent->GeneratedComponent->Rename( *NewComponentName );
			PCGManagedComponent->ForgetComponent();
		}
	}
	// To migrate the external actors spawned by the PCG to the chunk, we need to set the chunk as their owner (so they are picked up as exports by the serialization system)
	// and also add them to the array of owned chunk actors (so that they can be reached by the chunk serialization and persisted)
	// Also prefix their name with the chunk name and the chunk generator name to keep them structured
	else if ( UPCGManagedActors* PCGManagedActors = Cast<UPCGManagedActors>( ManagedResource ) )
	{
		for ( const TSoftObjectPtr<AActor>& ManagedActorSoftRef : PCGManagedActors->GeneratedActors )
		{
			AActor* ManagedActor = ManagedActorSoftRef.LoadSynchronous();
			check( IsValid( ManagedActor ) );
			
			const FString NewActorName = FString::Printf( TEXT("%s_%s_%s"), *GetChunk()->GetName(), *GetClass()->GetName(), *ManagedActor->GetName() );
			ManagedActor->Rename( *NewActorName );

			// Set the actor owner to the chunk and add the actor to the owned child actors collection
			ManagedActor->SetOwner( GetChunk() );
			GetChunk()->ChunkChildActors.Add( ManagedActor );
		}
		PCGManagedActors->GeneratedActors.Empty();
	}
}

void UPCGChunkGenerator::OnPCGGraphGenerationComplete_Implementation( UPCGComponent* PCGComponent )
{
	check( IsInGameThread() );
	bWaitingForPCGGraphToComplete = false;
}
